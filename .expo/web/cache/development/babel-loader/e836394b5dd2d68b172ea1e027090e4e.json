{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nvar _this = this,\n    _jsxFileName = \"/Users/juliakispert/Geocache/components/Compass.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as React from 'react';\nimport Alert from \"react-native-web/dist/exports/Alert\";\nimport Image from \"react-native-web/dist/exports/Image\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Text from \"react-native-web/dist/exports/Text\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport * as geolib from 'geolib';\nimport { Magnetometer } from 'expo-sensors';\nimport { useEffect, useState, useRef } from 'react';\nimport { atan } from 'react-native-reanimated';\n\nvar Compass = function Compass() {\n  var _Dimensions$get = Dimensions.get('window'),\n      width = _Dimensions$get.width,\n      height = _Dimensions$get.height;\n\n  var GOAL_LATITUDE = global.goalCache.latitude;\n  var GOAL_LONGITUDE = global.goalCache.longitude;\n\n  var _useState = useState(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      userLatitude = _useState2[0],\n      setUserLatitude = _useState2[1];\n\n  var _useState3 = useState(0),\n      _useState4 = _slicedToArray(_useState3, 2),\n      userLongitude = _useState4[0],\n      setUserLongitude = _useState4[1];\n\n  var _useState5 = useState(0),\n      _useState6 = _slicedToArray(_useState5, 2),\n      bearing = _useState6[0],\n      setBearing = _useState6[1];\n\n  var _useState7 = useState(-1),\n      _useState8 = _slicedToArray(_useState7, 2),\n      distance = _useState8[0],\n      setDistance = _useState8[1];\n\n  var findCoordinates = function findCoordinates() {\n    console.log(\"findCoordinates!\", \"existing subscription:\", subscriptionRef.current);\n\n    if (!subscriptionRef.current) {\n      return;\n    }\n\n    navigator.geolocation.getCurrentPosition(function (position) {\n      console.log(\"findCoordinates callback!\", \"existing subscription:\", subscriptionRef.current);\n\n      if (subscriptionRef.current) {\n        var lat = position.coords.latitude;\n        setUserLatitude(lat);\n        var long = position.coords.longitude;\n        setUserLongitude(long);\n      }\n    });\n  };\n\n  var changeBearing = function changeBearing() {\n    findCoordinates();\n\n    if (GOAL_LATITUDE != 0) {\n      if (!subscriptionRef.current) {\n        return;\n      }\n\n      var userBear = geolib.getGreatCircleBearing({\n        latitude: userLatitude,\n        longitude: userLongitude\n      }, {\n        latitude: GOAL_LATITUDE,\n        longitude: GOAL_LONGITUDE\n      });\n      setBearing(userBear);\n    } else {\n      Alert.alert(\"Error\", \"Return to Map of All Mac Caches To Pick Your Goal\", [{\n        text: \"Cancel\",\n        onPress: function onPress() {\n          return console.log(\"Cancel Pressed\");\n        },\n        style: \"cancel\"\n      }, {\n        text: \"OK\",\n        onPress: function onPress() {\n          return console.log(\"OK Pressed\");\n        }\n      }]);\n    }\n  };\n\n  var changeDistance = function changeDistance() {\n    if (GOAL_LATITUDE != 0) {\n      navigator.geolocation.getCurrentPosition(function (position) {\n        if (!subscriptionRef.current) {\n          return;\n        }\n\n        setDistance(geolib.getDistance({\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude\n        }, {\n          latitude: GOAL_LATITUDE,\n          longitude: GOAL_LONGITUDE\n        }));\n      });\n    } else {\n      Alert.alert(\"Error\", \"Return to Map of All Mac Caches To Pick Your Goal\", [{\n        text: \"Cancel\",\n        onPress: function onPress() {\n          return console.log(\"Cancel Pressed\");\n        },\n        style: \"cancel\"\n      }, {\n        text: \"OK\",\n        onPress: function onPress() {\n          return console.log(\"OK Pressed\");\n        }\n      }]);\n    }\n  };\n\n  var _useState9 = useState(null),\n      _useState10 = _slicedToArray(_useState9, 2),\n      subscription = _useState10[0],\n      setSubscription = _useState10[1];\n\n  var _useState11 = useState(0),\n      _useState12 = _slicedToArray(_useState11, 2),\n      magnetometer = _useState12[0],\n      setMagnetometer = _useState12[1];\n\n  var subscriptionRef = useRef(false);\n  useEffect(function () {\n    _subscribe();\n\n    return function () {\n      _unsubscribe();\n    };\n  }, []);\n\n  var _subscribe = function _subscribe() {\n    subscriptionRef.current = true;\n    Magnetometer.addListener(function (data) {\n      setMagnetometer(_angle(data));\n      changeBearing();\n      changeDistance();\n    });\n    console.log(\"subscribing\", subscriptionRef);\n  };\n\n  var _unsubscribe = function _unsubscribe() {\n    subscriptionRef.current = false;\n    Magnetometer.removeAllListeners();\n    setMagnetometer(null);\n    console.log(\"unsubscribing\", subscriptionRef);\n  };\n\n  var _angle = function _angle(magnetometer) {\n    if (magnetometer) {\n      var x = magnetometer.x,\n          y = magnetometer.y;\n      angle = Math.round(atan2Normalized(x, y));\n    }\n\n    return angle;\n  };\n\n  function atan2Normalized(x, y) {\n    var result = Math.degrees(Math.atan2(y, x));\n\n    if (result < 0) {\n      result = (360 + result) % 360;\n    }\n\n    return result;\n  }\n\n  Math.radians = function (degrees) {\n    return degrees * (Math.PI / 180);\n  };\n\n  Math.degrees = function (radians) {\n    return radians * (180 / Math.PI);\n  };\n\n  var _finalAngle = function _finalAngle() {\n    if (bearing === magnetometer) {\n      return 0;\n    } else if (bearing < _angle) {\n      return Math.abs((magnetometer - bearing) % 360);\n    } else {\n      return (bearing + magnetometer) % 360;\n    }\n  };\n\n  return React.createElement(View, {\n    style: [styles.compass],\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 201,\n      columnNumber: 5\n    }\n  }, React.createElement(Image, {\n    style: {\n      height: height / 2,\n      width: width / 2,\n      resizeMode: 'contain',\n      transform: [{\n        rotate: _finalAngle() + 'deg'\n      }]\n    },\n    source: require(\"./images/arrow.png\"),\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 202,\n      columnNumber: 7\n    }\n  }), React.createElement(Text, {\n    style: styles.text,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 212,\n      columnNumber: 7\n    }\n  }, \" Distance to Goal:  \"), React.createElement(Text, {\n    style: styles.text,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 213,\n      columnNumber: 7\n    }\n  }, \" \", distance, \" m \"), React.createElement(Text, {\n    style: styles.text,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 7\n    }\n  }, \" (Hold Phone Parallel To Ground) \"));\n};\n\nvar styles = StyleSheet.create({\n  text: _objectSpread(_objectSpread({}, Platform.select({\n    android: {\n      fontFamily: 'normal'\n    },\n    ios: {\n      fontFamily: 'Futura'\n    }\n  })), {}, {\n    alignItems: 'center',\n    color: 'white',\n    fontWeight: 'bold'\n  }),\n  compass: {\n    width: Dimensions.get('window').width,\n    height: Dimensions.get('window').height * 0.7,\n    alignSelf: 'center',\n    marginBottom: 35,\n    marginTop: 10,\n    backgroundColor: 'orange',\n    alignItems: 'center'\n  }\n});\nexport default Compass;","map":{"version":3,"sources":["/Users/juliakispert/Geocache/components/Compass.js"],"names":["React","geolib","Magnetometer","useEffect","useState","useRef","atan","Compass","Dimensions","get","width","height","GOAL_LATITUDE","global","goalCache","latitude","GOAL_LONGITUDE","longitude","userLatitude","setUserLatitude","userLongitude","setUserLongitude","bearing","setBearing","distance","setDistance","findCoordinates","console","log","subscriptionRef","current","navigator","geolocation","getCurrentPosition","position","lat","coords","long","changeBearing","userBear","getGreatCircleBearing","Alert","alert","text","onPress","style","changeDistance","getDistance","subscription","setSubscription","magnetometer","setMagnetometer","_subscribe","_unsubscribe","addListener","data","_angle","removeAllListeners","x","y","angle","Math","round","atan2Normalized","result","degrees","atan2","radians","PI","_finalAngle","abs","styles","compass","resizeMode","transform","rotate","require","StyleSheet","create","Platform","select","android","fontFamily","ios","alignItems","color","fontWeight","alignSelf","marginBottom","marginTop","backgroundColor"],"mappings":"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","sourcesContent":["//Created by A'di with help from other group members (Subscription and angle from Julia)\n//\n//This component creates an arrow that uses the bearing between location and goal\n//and compass heading in order to rotate a picture of an arrow that directs user to \n//goal location (the Scot).\n\n\nimport * as React from 'react';\nimport { Alert, Image, View, Text, StyleSheet, Dimensions, Platform} from 'react-native';\nimport * as geolib from 'geolib';\nimport { Magnetometer } from 'expo-sensors';\nimport { useEffect, useState, useRef} from 'react';\nimport { atan } from 'react-native-reanimated';\n\n\n\nconst Compass = () => {\n\n  const { width, height } = Dimensions.get('window');\n  const GOAL_LATITUDE = global.goalCache.latitude;\n  const GOAL_LONGITUDE = global.goalCache.longitude;\n\n  const [userLatitude, setUserLatitude] = useState(0);\n  const [userLongitude, setUserLongitude] = useState(0);\n  const [bearing, setBearing] = useState(0);\n  const [distance, setDistance] = useState(-1);\n\n\n\n  //finds user coordinates and updates user latitude and longitude states\n  //Code by Julia and modified for compass by A'di\n\n  const findCoordinates = () => {\n    console.log(\"findCoordinates!\", \"existing subscription:\", subscriptionRef.current);\n\n    if (!subscriptionRef.current) {\n      return;\n    }\n    navigator.geolocation.getCurrentPosition(\n      position => {\n        console.log(\"findCoordinates callback!\", \"existing subscription:\", subscriptionRef.current);\n        if(subscriptionRef.current){\n        const lat = position.coords.latitude;\n        setUserLatitude(lat);\n        const long = position.coords.longitude;\n        setUserLongitude(long);\n        }\n      },\n    );\n\n  };\n\n  //Updates bearing based on current user coordinates\n  const changeBearing = () => {\n    findCoordinates();\n    //Explanation/docs here: https://www.npmjs.com/package/geolib\n    //Gets bearing as angle (bearing is the cardinal angle between one coordinate\n    //point and another. In this case from user to goal)\n    if (GOAL_LATITUDE != 0) {\n      if(!subscriptionRef.current){\n        return; \n      }\n      const userBear = geolib.getGreatCircleBearing(\n        { latitude: userLatitude, longitude: userLongitude }, //user location\n        { latitude: GOAL_LATITUDE, longitude: GOAL_LONGITUDE }); //goal\n      setBearing(userBear);\n    } else {\n      Alert.alert(\n        \"Error\",\n        \"Return to Map of All Mac Caches To Pick Your Goal\",\n        [\n          {\n            text: \"Cancel\",\n            onPress: () => console.log(\"Cancel Pressed\"),\n            style: \"cancel\"\n          },\n          { text: \"OK\", onPress: () => console.log(\"OK Pressed\") }\n        ]\n      );\n    }\n  }\n\n   //Finds distance between user and goal coordinates and updates distance text component appropriately.\n   const changeDistance = () => {\n    //must write check here as well for if goal cache is null \n    if (GOAL_LATITUDE != 0) {\n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          if(!subscriptionRef.current){\n            return; \n          }\n          setDistance(geolib.getDistance(\n            { latitude: position.coords.latitude, longitude: position.coords.longitude },\n            { latitude: GOAL_LATITUDE, longitude: GOAL_LONGITUDE }\n          )\n          );\n        });\n    } else {\n      Alert.alert(\n        \"Error\",\n        \"Return to Map of All Mac Caches To Pick Your Goal\",\n        [\n          {\n            text: \"Cancel\",\n            onPress: () => console.log(\"Cancel Pressed\"),\n            style: \"cancel\"\n          },\n          { text: \"OK\", onPress: () => console.log(\"OK Pressed\") }\n        ]\n      );\n\n    }\n\n  }\n\n  //magnetometer returns the cardinal angle in degrees east of north the user is facing\n  //Aka Heading\n  const [subscription, setSubscription] = useState(null);\n  const [magnetometer, setMagnetometer] = useState(0);\n\n  const subscriptionRef = useRef(false); \n  //Turns compass and runs toggle methods\n  useEffect(() => {\n   _subscribe(); \n    return () => {\n      _unsubscribe();\n    };\n  }, []);\n\n  //Turns Magnetometer on and sends angle of phone\n  const _subscribe = () => {\n    subscriptionRef.current = true; \n    Magnetometer.addListener((data) => {\n      setMagnetometer(_angle(data));\n      changeBearing();\n      changeDistance();\n    });\n    \n    console.log(\"subscribing\", subscriptionRef); \n  };\n\n  //removes subscription and should stop the whole screen\n  const _unsubscribe = () => {\n    // subscription && subscription.remove();\n    subscriptionRef.current = false; \n    Magnetometer.removeAllListeners(); \n    setMagnetometer(null);\n    \n    console.log(\"unsubscribing\", subscriptionRef); \n  };\n\n\n\n  //Uses magnetometer to find the angle of which the phone is at.\n  //Based off of this stack overflow: https://stackoverflow.com/questions/57308560/smooth-orientation-compass-using-react-native-sensorss-magnetometer\n  const _angle = (magnetometer) => {\n    if (magnetometer) {\n      let { x, y} = magnetometer;\n      angle = Math.round(atan2Normalized(x, y));\n    }\n    return angle;\n  };\n\n  //normalizes atan2 so that it covers 0 to 360 degrees\nfunction atan2Normalized(x,y) {\n  let result = Math.degrees(Math.atan2(y,x));\n  if (result < 0){\n      result = (360+result)%360;\n  }\n  return result;\n}\n\n//turns degrees to radians\nMath.radians = function(degrees) {\nreturn degrees * (Math.PI / 180);\n}\n\n//turns radians to degrees\nMath.degrees = function(radians) {\nreturn radians * (180 / Math.PI);\n}\n\n  //Mathematical Reasoning (A'di's): If the bearing is less than the heading then we need to \n  //rotate counter clockwise (negative angle), and if the bearing is greater than the heading\n  //we need to rotate clockwise (positive angle). This function finds the angle of arrow rotation. \n  const _finalAngle = () => {\n    if (bearing === magnetometer){\n        return 0;\n    }\n    else if (bearing < _angle){\n        return Math.abs((magnetometer - bearing)%360);\n    }\n    else{\n        return ((bearing + magnetometer))%360;\n        \n    }\n  }\n\n  // style done by Julia to make it look better for testing.\n  return (\n    <View style={[styles.compass]}>\n      <Image\n        style={{\n          height: height / 2,\n          width: width / 2,\n          resizeMode: 'contain',\n          transform: [{ rotate: _finalAngle() + 'deg' }]\n        }}\n        source={require('./images/arrow.png')}\n\n      />\n      <Text style={styles.text}> Distance to Goal:  </Text>\n      <Text style={styles.text}> {distance} m </Text>\n      <Text style={styles.text}> (Hold Phone Parallel To Ground) </Text>\n    </View>\n  );\n\n}\nconst styles = StyleSheet.create({\n  text: {\n    ...Platform.select({\n      android: {\n        fontFamily: 'normal'},\n      ios: {\n        fontFamily: 'Futura'}\n      }),\n    alignItems: 'center',\n    color: 'white',\n    fontWeight: 'bold',\n    \n\n  },\n  compass: {\n    width: Dimensions.get('window').width,\n    height: Dimensions.get('window').height * 0.7,\n    alignSelf: 'center',\n    marginBottom: 35,\n    marginTop: 10,\n    backgroundColor: 'orange',\n    alignItems: 'center',\n  },\n});\n\n\n\nexport default Compass;"]},"metadata":{},"sourceType":"module"}